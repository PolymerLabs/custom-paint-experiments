<link rel="import" href="../polymer/polymer-element.html">
<dom-module id="paint-underlay">
  <template>
    <style>
      #underlay {
        position: absolute;
        width: 100%;
        height: 100%;
      }
      #content {
        position: relative;
      }
      :host {
        display: block;
        position: relative;
      }
    </style>
    <canvas id="underlay"></canvas>
    <div id="content">
      <slot name="content"></slot>
    </div>
  </template>
</dom-module>

<script>
class PaintUnderlay extends Polymer.Element {
  static get is() { return 'paint-underlay'; }
  static get config() {
    return {
      properties: {
        paint: String,
        autoUpdateStyle: {type: Boolean, value: false},
        autoUpdateGeometry: {type: Boolean, value: false},
      },
      observers: [
        '_paintChanged(paint)',
      ],
    };
  }

  constructor() {
    super();
  }
  connectedCallback() {
    this._connected = true;
    super.connectedCallback();
    this._scheduleAnimation();
  }
  disconnectedCallback() {
    this._connected = false;
    super.disconnectedCallback();
  }
  ready() {
    super.ready();

    if (!this.paint) {
      return;
    }

  }

  updateGeometry() {
    if (this._canvasPainter) {
      this._canvasPainter.updateGeometry(this);
    }
  }
  updateStyle() {
    if (this._canvasPainter) {
      this._canvasPainter.updateStyle(this);
    }
  }
  repaint() {
    if (this._canvasPainter) {
      this._canvasPainter.repaint();
    }
  }

  _paintChanged(paint) {
    Painters.get(this.paint).then(painter => {
      if (this.paint == paint)
        this._initPainter(painter);
    });
  }

  _initPainter(painter) {
    if (NativePaint.available) {
      this.$.underlay.width = 0;
      this.$.underlay.height = 0;
      this.$.underlay.style.backgroundImage = `paint(${this.paint})`;
    } else {
      this._canvasPainter = new CanvasPainter({
        canvas: pu.$.underlay,
        painter: new painter(),
      });
      this._scheduleAnimation();
    }
  }
  get _fallbackActive() {
    // FIXME: Check native.
    return this._connected;
  }
  _animationCallback() {
    this._rafId = undefined;
    if (!this._fallbackActive) {
      return;
    }
    if (this.autoUpdateGeometry) {
      this.updateGeometry();
    }
    if (this.autoUpdateStyle) {
      this.updateStyle();
    }
    this.repaint();
    if (this.autoUpdateGeometry || this.autoUpdateStyle) {
      this._scheduleAnimation();
    }
  }
  _scheduleAnimation() {
    if (!this._fallbackActive) {
      return;
    }
    this._rafId = requestAnimationFrame(t => this._animationCallback());
  }
}
customElements.define(PaintUnderlay.is, PaintUnderlay);
</script>

